<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kraken Dial – CPU / GPU / Liquid (arcs + pulse CPU)</title>
  <style>
    :root {
      --bg1: #0b0b0c;
      --bg2: #1a1a1d;
      --fg: #e7e7ea;
      --muted: #9aa0a6;
      --ok: #9fe870;
      --warn: #ffd166;
      --hot: #ff6b6b;
      --grid: rgba(255,255,255,.08);
      --line: rgba(231,231,234,.9);
    }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      display: grid; place-items: center;
      overflow: hidden;
      background: radial-gradient(circle at center, var(--bg2) 0%, var(--bg1) 100%);
      animation: pulse 6s ease-in-out infinite;
    }
    @keyframes pulse {
      0%,100% { background-size: 100% 100%; }
      50% { background-size: 120% 120%; }
    }

    #app { display:none; width: 100vmin; height: 100vmin; max-width:100vw; max-height:100vh; aspect-ratio:1/1; border-radius:50%; overflow:hidden; position:relative; backdrop-filter: blur(4px); }
    #app.active { display:block; }
    #dial { width:100%; height:100%; display:block; }
    .center { position:absolute; inset:0; display:grid; place-items:center; text-align:center; line-height:1.1; pointer-events:none; }
    .labels { display:grid; gap:.5em; }
    .row { display:flex; gap:2.5em; justify-content:center; }
    .lbl { font-size: clamp(14px, 5vmin, 28px); color: var(--muted); letter-spacing:.1em; text-transform:uppercase; font-weight:700; }
    .val { font-variant-numeric: tabular-nums; font-weight:900; font-size: clamp(28px, 10vmin, 80px); }
    .unit { font-size:.55em; opacity:.8; margin-left:.15em; font-weight:700; }
    #dbg{position:fixed;left:8px;bottom:8px;font:12px/1.3 system-ui;background:rgba(0,0,0,.55);color:#fff;padding:6px 8px;border-radius:8px;display:none;white-space:pre;z-index:9}
    #dbg.on{display:block}
  </style>
</head>
<body>
  <div id="app">
    <div id="dbg"></div>
    <canvas id="dial"></canvas>
    <div class="center">
      <div class="labels">
        <div class="row"><span class="lbl">CPU</span><span class="lbl">GPU</span><span class="lbl">LIQUID</span></div>
        <div class="row"><span class="val" id="cpu">--<span class="unit">°C</span></span><span class="val" id="gpu">--<span class="unit">°C</span></span><span class="val" id="liq">--<span class="unit">°C</span></span></div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const $ = (id) => document.getElementById(id);
    const fmt = (n) => (n==null || Number.isNaN(n)) ? "--" : Math.round(n).toString();
    const level = (t) => t==null?"ok":(t<60?"ok":t<80?"warn":"hot");
    const getVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    const app = $("app"), canvas = $("dial"), ctx = canvas.getContext('2d');
    const hist = { cpu: [], gpu: [], liq: [] };
    const nz = (window.nzxt && window.nzxt.v1) || {};
    const fps = Number(nz.targetFps) || 30;
    const MAX = Math.round(fps * 180 / 30);

    function resize(){
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      draw();
    }
    window.addEventListener('resize', resize);

    function push(arr, v){
      if (typeof v === 'number' && !Number.isNaN(v)) arr.push(v);
      else if (arr.length) arr.push(arr[arr.length-1]);
      else arr.push(0);
      if (arr.length > MAX) arr.shift();
    }

    function autoScale(arr){
      if (!arr.length) return {min:20, max:100};
      let min = Math.max(15, Math.min(...arr) - 4);
      let max = Math.min(110, Math.max(...arr) + 4);
      if (max - min < 10) max = min + 10;
      return {min, max};
    }

    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight; if (!w||!h) return;
      const cx = w/2, cy = h/2; const R = Math.min(w,h)/2 - 10;
      ctx.clearRect(0,0,w,h);

      // === FOND ANIMÉ piloté UNIQUEMENT par la température CPU ===
      const now = performance.now()/1000;
      const lastCpu = hist.cpu[hist.cpu.length-1];
      if (typeof lastCpu === 'number' && !Number.isNaN(lastCpu)){
        const heat = Math.min(1, Math.max(0, (lastCpu - 30) / 50)); // 30°C→0, 80°C→1
        // vitesse et amplitude augmentent avec la chaleur
        const speed = 1.6 + 1.4*heat;                // 1.6x à 3.0x
        const pulse = 0.55 + 0.45*Math.sin(now*speed);
        const haloR = R * (0.70 + 0.10*pulse + 0.18*heat); // rayon plus grand quand c'est chaud
        const col = heat<.33 ? getVar('--ok') : heat<.66 ? getVar('--warn') : getVar('--hot');
        const rgba = (rgb, a)=> rgb.trim().startsWith('rgba') ? rgb : rgb.replace('rgb', 'rgba').replace(')', `, ${a})`);
        ctx.save(); ctx.translate(cx, cy);
        const grad = ctx.createRadialGradient(0,0, Math.max(0,haloR*0.15), 0,0, haloR);
        grad.addColorStop(0, rgba(col, 0.20 + 0.30*heat)); // intensité dépend de la chaleur
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0,0, haloR, 0, Math.PI*2); ctx.fill();
        // léger balayage périphérique (toujours présent, mais drive par CPU aussi)
        const sweepA = now * (0.6 + 0.6*heat);
        const sweepW = Math.PI * (0.14 + 0.08*heat);
        ctx.globalAlpha = 0.12 + 0.20*heat;
        ctx.fillStyle = rgba(col, 0.65);
        ctx.beginPath();
        ctx.arc(0,0, R-6, sweepA, sweepA + sweepW, false);
        ctx.arc(0,0, R-46, sweepA + sweepW, sweepA, true);
        ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
      }

      // === GRILLE RADIALE ===
      ctx.save();
      ctx.translate(cx, cy);
      ctx.strokeStyle = getVar('--grid');
      ctx.lineWidth = 1;
      ctx.globalAlpha = .6;
      for (let i=1;i<=3;i++){ const r = (R * i)/4; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); }
      ctx.restore();

      // === ANNEAUX HISTORIQUES ===
      const rings = [
        { key:'cpu',  r1: R-8, r2: R-38 },
        { key:'gpu',  r1: R-44, r2: R-74 },
        { key:'liq',  r1: R-80, r2: R-110 },
      ];

      rings.forEach((ring)=>{
        const arr = hist[ring.key]; if (arr.length < 2) return;
        const {min,max} = autoScale(arr);
        const a0 = -Math.PI*0.8;
        const a1 =  Math.PI*0.8;
        const span = a1 - a0;
        const L = Math.min(arr.length, MAX);
        ctx.save(); ctx.translate(cx, cy);
        ctx.globalAlpha = .30; ctx.fillStyle = getVar('--grid');
        drawRing(ring.r1, ring.r2, a0, a1, true);
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.strokeStyle = getVar('--line');
        for (let i = 0; i < L; i++){
          const t = i/(MAX-1);
          const a = a0 + t*span;
          const v = arr[arr.length - L + i];
          const k = (v - min) / (max - min);
          const r = ring.r2 + (ring.r1 - ring.r2) * Math.min(Math.max(k,0),1);
          const x = Math.cos(a) * r, y = Math.sin(a) * r;
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.restore();
      });
    }

    function drawRing(rOuter, rInner, a0, a1, fill){(rOuter, rInner, a0, a1, fill){
      ctx.beginPath();
      ctx.arc(0,0,rOuter,a0,a1,false);
      ctx.arc(0,0,rInner,a1,a0,true);
      ctx.closePath();
      if (fill) ctx.fill(); else ctx.stroke();
    }

    function paintValues(cpu, gpu, liq){
      $('cpu').firstChild.nodeValue = fmt(cpu);
      $('gpu').firstChild.nodeValue = fmt(gpu);
      $('liq').firstChild.nodeValue = fmt(liq);
      const col = (t)=> getVar(`--${level(t)}`);
      $('cpu').style.color = col(cpu);
      $('gpu').style.color = col(gpu);
      $('liq').style.color = col(liq);
      draw();
    }

    const params = new URLSearchParams(location.search);
    const isDemo = params.get('demo') === '1';
    const isDebug = params.get('debug') === '1';
    const dbg = document.getElementById('dbg');
    function logDbg(msg){ if (!isDebug) return; dbg.classList.add('on'); dbg.textContent = String(msg); }
    logDbg('en attente de CAM…');{ if (!isDebug) return; dbg.classList.add('on'); dbg.textContent = String(msg); }

    let armed = false;
    let attached = false; // a-t-on installé notre handler dans nzxt.v1 ?
    function handleMonitoringData(data){
      try {
        const cpu = Array.isArray(data?.cpus) ? data.cpus[0]?.temperature : data?.cpu?.temperature;
        const gpu = Array.isArray(data?.gpus)
          ? Math.max(...data.gpus.map(g => g?.temperature ?? -Infinity))
          : data?.gpu?.temperature;
        const liq = data?.kraken?.liquidTemperature ?? data?.kraken?.liquidTemp ?? data?.cooler?.liquidTemp ?? data?.liquid?.temperature;
        const okCpu = (typeof cpu === 'number' && !Number.isNaN(cpu));
        const okGpu = (typeof gpu === 'number' && !Number.isNaN(gpu));
        const okLiq = (typeof liq === 'number' && !Number.isNaN(liq));
        if (okCpu && okGpu && okLiq){
          if (!armed){ armed = true; app.classList.add('active'); resize(); }
          push(hist.cpu, cpu); push(hist.gpu, gpu); push(hist.liq, liq);
          paintValues(cpu,gpu,liq);
          logDbg(`OK CPU:${Math.round(cpu)} GPU:${Math.round(gpu)} LIQ:${Math.round(liq)}${attached?' (attached)':''}`);
        } else {
          logDbg(`invalid cpu:${cpu} gpu:${gpu} liq:${liq}${attached?' (handler attaché)':' (handler non attaché)'});
        }
      } catch (e) { logDbg('Erreur données'); }
    }
          push(hist.cpu, cpu); push(hist.gpu, gpu); push(hist.liq, liq);
          paintValues(cpu,gpu,liq);
          logDbg(`OK CPU:${cpu} GPU:${gpu} LIQ:${liq}`);
        } else {
          logDbg(`invalid cpu:${cpu} gpu:${gpu} liq:${liq}`);
        }
      } catch (e) { logDbg('Erreur données'); }
    }

    // (ré)installe régulièrement le handler car CAM peut injecter/écraser window.nzxt APRÈS le chargement
    function installHandler(){
      try{
        if (!window.nzxt) window.nzxt = {};
        if (!window.nzxt.v1) window.nzxt.v1 = {};
        if (window.nzxt.v1.onMonitoringDataUpdate !== handleMonitoringData){
          window.nzxt.v1.onMonitoringDataUpdate = handleMonitoringData;
          attached = true; logDbg('handler CAM installé');
        }
        if (typeof window.nzxt.v1.subscribeMonitoringData === 'function'){
          try { window.nzxt.v1.subscribeMonitoringData(handleMonitoringData); attached = true; logDbg('subscribe OK'); } catch(_){}
        }
      }catch(e){ /* ignore */ }
    }
    installHandler();
    const reattach = setInterval(()=>{ if (!armed) installHandler(); else clearInterval(reattach); }, 1500);
    }

    if (isDemo){
      app.classList.add('active');
      resize();
      let t=0, cpu=37, gpu=40, liq=31;
      setInterval(()=>{
        t+=1; cpu = 35 + 10*Math.sin(t/6); gpu = 38 + 14*Math.sin(t/7 + 1.2); liq = 30 + 3*Math.sin(t/10);
        push(hist.cpu, cpu); push(hist.gpu, gpu); push(hist.liq, liq);
        paintValues(cpu,gpu,liq);
        logDbg('MODE DEMO');
      }, 1000);
    }
    // boucle d'animation continue pour que le pulse soit présent en permanence
    function loop(){ draw(); requestAnimationFrame(loop); }
    // ⚠️ fix: initialiser la taille du canvas avant de démarrer la boucle
    resize();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
